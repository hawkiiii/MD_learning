## 原理

联系生活中的场景，例如经纪人、中介、黄牛、婚介等，这些是代理的对象，Java中称为**代理对象**，对应的类型称**代理类**，被代理的实际对象称为**目标对象**，对应的类型称为**目标类**。目标对象可以委托代理对象去完成一些工作。在编程中代理模式主要有两个目的：保护目标对象、增强目标对象功能。

## 分类

## 静态代理

例如把A类看作目标类，实现了接口AInterface，我们可以写一个AProxy类作为A类的代理类，在AProxy类中声明对A类的引用，接着可以在代理类中编写一个对A类方法前后增强的方法，实现代理功能

## 动态代理与静态代理的对比

动态代理是在程序运行时，生成新的代理类，静态代理是在程序编译前写好的。

## 动态代理

## jdk动态代理

流程

1. 拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。
2. JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。
3. 动态生成 Java 代码，类中包含Invocationhandle的引用，把新加的业务逻辑方法由一定的逻辑代码去调用
4. 编译新生成的 Java 代码.class。
5. 再重新加载到 JVM 中运行。

应用

编写一个代理类，实现Invocationhandle，重写invoke方法，在invoke方法中调用method.invoke()前后可以添加扩展的业务模块

## cjlib动态代理

流程

1. 拿到被代理对象的引用，生成一个继承自这个目标类的代理类，一个目标类的FastClass和一个代理类的FastClass，总共生成三个class文件
2. 代理类中重写了所有目标类的方法，并且添加每个方法的代理的方法
3. 实际调用时，生成代理类与目标类的FastClass，FastClass中的机制是通过int类型数据定位需要调用的方法，这样省去了反射的调用。

**CGLib 和 JDK 动态代理对比**

1.  JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。 
2. CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标对象 实现的动态代理
3. JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。
4.  JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高

运行时cglib效率为什么高：

高CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了 FastClass 机 制，它的原理简单来说就是：**为代理类和被代理类各生成一个 Class，这个 Class 会为代 理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass 就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK 动态代理通过反射调用高。**

FastClass 并不是跟代理类一块生成的，而是在第一次执行MethodProxyinvoke/invokeSuper 时生成的并放在了缓存中。