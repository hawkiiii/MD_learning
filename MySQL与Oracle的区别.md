## MySQL与Oracle的区别

1. MySQL默认是自动提交，Oracle默认不自动提交，需要用户手动提交，需要写==commit==，指令或者点击commit

2. MySQL直接在sql与剧中写==limit==就可以实现分页，Oracle需要用到伪列==rownum==和==嵌套查询==

3. MySQL是read commited的隔离级别，而Oracle是repeated read的隔离级别，同时二者都支持串行化事务隔离级别

   一致性
   oracle:
   oracle支持serializable的隔离级别，可以实现最高级别的读一致性。每个session提交后其他session才能看到提交的更改。oracle通过在undo表空间中构造多版本数据块来实现读一致性，
   每个session查询时，如果对应的数据块发生变化，oracle会在undo表空间中为这个session构造它查询时的旧的数据块。

   mysql:
   mysql没有类似oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。
   session更新数据时，要加上排它锁，其他session无法访问数据。

   | 事务隔离级别               | 脏读 | 不可重复读 | 幻读 |
   | -------------------------- | ---- | ---------- | ---- |
   | 读未提交(read-uncommitted) | 是   | 是         | 是   |
   | 不可重复读(read-committed) | 否   | 是         | 是   |
   | 可重复读(repeatable-read)  | 否   | 否         | 是   |
   | 串行化(serializable)       | 否   | 否         | 否   |

4. MySQL在innodb存储引擎的行级锁的情况下才可支持事务，oracle==完全支持事务==

5. MySQL数据库更新或者重启，则会丢失数据，Oracle把提交的sql操作栈写入了在线联机日志文件中，保持到了磁盘上，可以随时恢复

6. MySQL以表级锁为主，资源粒度很大，Oracle使用行级锁

7. MySQL逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用，Oracle逻辑备份时不需要锁定数据，且备份的数据是一致的

8. MySQL时轻量级数据库，并且免费，没有服务恢复数据。Oracle是重量型数据库，收费

9. MySql一般使用自动增长类型，创建表指定表的主键为auto increment，插入记录时就不需要再为主键添加记录了，主键会自动增长。Oracle中没有自动增长，主键一般使用序列，插入记录时将序列号的下一值付给该字段即可，只是ORM框架只是需要native主键生成策略即可

10. MySql里可以使用双引号来包起字符串，Oracle里要使用==单引号==包起字符串。

11. mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。
    oracle在这方面感觉更加稳重传统一些。

12. mysql使用concat()函数连接字符串，oracle不仅有concat()函数，还可以使用||；

13. mysql没有全外连接，使用集合连接代替，oracle有全外连接，而且左右外连接有自己的语法：(+)；

14. mysql分页使用limit，oracle分页得借助rownum关键字；

15. mysql自动增长auto_increment，oracle使用序列代替；

16. mysql直接书写循环判断语句，oracle得借助PLSQL语句；

17. mysql判断使用elseif，oracle使用elsif；

18. mysql可以直接增删改，oracle需要commit；

19. group by，在下oracle下用group by的话，group by后面的字段必须在select后面出现，不然会报错的，而mysql却不会；

20. 费用：MySQL是开源的项目（免费），Oracle数据库产品是闭源同时也是收费的。

    Mysql是中小型数据库，oracle是大型的

21. MYSQL有自动增长的数据类型，插入记录时不用操作此字段，会自动获得数据值。ORACLE没有自动增长的数据类型，需要建立一个自动增长的序列号，插入记录时要把序列号的下一个值赋于此字段

22. 事务：MySQL对于事务默认是不支持的，只有某些存储引擎中如：innodb可以支持。 而Oracle对于事务是完全支持，不管是OLTP还是OLAT都是支持的。

23. MYSQL里可以用双引号包起字符串，ORACLE里只可以用单引号包起字符串。在插入和修改字符串前必须做单引号的替换：把所有出现的一个单引号替换成两个单引号

24. 分页：MYSQL处理翻页的SQL语句比较简单，用LIMIT 开始位置, 记录个数。ORACLE处理翻页的SQL语句就比较繁琐了。每个结果集只有一个ROWNUM字段标明它的位置, 并且只能用ROWNUM<100, 不能用ROWNUM>80。

25. 日期：MYSQL日期字段分DATE和TIME两种，ORACLE日期字段只有DATE，包含年月日时分秒信息，用当前数据库的系统时间为SYSDATE, 精确到秒。

26. MYSQL里用 字段名 like '%字符串%',ORACLE里也可以用 字段名 like '%字符串%' 但这种方法不能使用索引, 速度不快，用字符串比较函数 instr(字段名,'字符串')>0 会得到更精确的查找结果。

27. MYSQL的非空字段也有空的内容，ORACLE里定义了非空字段就不容许有空的内容。按MYSQL的NOT NULL来定义ORACLE表结构, 导数据的时候会产生错误。因此导数据时要对空字符进行判断，如果为NULL或空字符，需要把它改成一个空格的字符串。

28. 1：MySQL的实例是用户登录是系统分配给用户的，而用户必须是先在MySQL中创建好，然后登陆用户mysql -u user_name -p然后使用show databases; 命令查看数据库，在使用 use database_name database; 选择数据库,这样才可以对数据库进行操作。简单的关系就是：instance > database

    2：Oracle的实例是在创建数据库时就默认创建好的，而用户基于数据库实例，实例之间可以没有关系所以其中的用户也不尽相同，你登录不同的实例就相当于登录了不同的数据库，登陆的命令也能简单sqlplus user_name/password@IP:port/instance_name 其中可以把IP地址，端口号，实例名写在一个TNS文件中取一个别名，登陆的时候输入这个别名就行了。简单的是：instance = database

29. MySQL是单进程多线程，Oracle是多进程(在Windows下也是单进程)，Windows 下只能使用一个用户，或者你可以在不同用户之间做切换，而Linux是多用 户或者相同用户可以同时连接操作系统

30. 并发性
    并发性是oltp数据库最重要的特性，但并发涉及到资源的获取、共享与锁定。
    mysql:
    mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。
    虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。
    oracle:
    oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。

31. 数据持久性
    oracle: 保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。
    mysql: 默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。

32. 逻辑备份
    oracle逻辑备份时不锁定数据，且备份的数据是一致的。
    mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用。
    
33. 热备份
    oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。
    mysql:
    myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。
    innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。
    innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。

34. 复制
    oracle:既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。
    mysql:复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。
    
35. 性能诊断
    oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等
    mysql的诊断调优方法较少，主要有慢查询日志。
    
36. 权限与安全
    mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。
    oracle的权限与安全概念比较传统，中规中矩。
    
37. 分区表和分区索引
    oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。
    mysql的分区表还不太成熟稳定。
    
    

## Oracle也Mysql操作上的一些区别

1. 主键 Mysql一般使用自动增长类型，在创建表时只要指定表的主键为auto increment,插入记录时，不需要再指定该记录的主键值，Mysql将自动增长；Oracle没有自动增长类型，主键一般使用的序列，插入记录时将序列号的下一个值付给该字段即可；只是ORM框架是只要是native主键生成策略即可。

2. 单引号的处理 MYSQL里可以用双引号包起字符串，ORACLE里只可以用单引号包起字符串。在插入和修改字符串前必须做单引号的替换：把所有出现的一个单引号替换成两个单引号。

3. 翻页的SQL语句的处理 MYSQL处理翻页的SQL语句比较简单，用LIMIT 开始位置, 记录个数；ORACLE处理翻页的SQL语句就比较繁琐了。每个结果集只有一个ROWNUM字段标明它的位置, 并且只能用ROWNUM<100, 不能用ROWNUM>80

4. 长字符串的处理 长字符串的处理ORACLE也有它特殊的地方。INSERT和UPDATE时最大可操作的字符串长度小于等于4000个单字节, 如果要插入更长的字符串, 请考虑字段用CLOB类型，方法借用ORACLE里自带的DBMS_LOB程序包。插入修改记录前一定要做进行非空和长度判断，不能为空的字段值和超出长度字段值都应该提出警告,返回上次操作。 
5. 空字符的处理 MYSQL的非空字段也有空的内容，ORACLE里定义了非空字段就不容许有空的内容。按MYSQL的NOT NULL来定义ORACLE表结构, 导数据的时候会产生错误。因此导数据时要对空字符进行判断，如果为NULL或空字符，需要把它改成一个空格的字符串。
6. 字符串的模糊比较 MYSQL里用 字段名 like '%字符串%',ORACLE里也可以用 字段名 like '%字符串%' 但这种方法不能使用索引, 速度不快。
  