

# MySql

sqlSession 怎么做成 线程安全的。

[SqlSessionTemplate是如何保证MyBatis中SqlSession的线程安全的？](https://blog.csdn.net/xlgen157387/article/details/79438676)

[spring管理mybatis——sqlSession线程安全性](https://www.cnblogs.com/zcmzex/p/9005194.html)

# 线程

## 创建线程方式

四种

1. 继承Thread类，重写run，单继承，static共享数据
2. 实现Runnable接口，重写run，比上一个好
3. 实现Callable接口，FutureTask返回值
4. 开一个线程池ConnectionPool，优点：复用，创建使用销毁。

## 谈谈同步代码块中同步监视器和共享数据的理解及各自要求？

- 同步监视器——锁
  - 任何一个类的对象可以充当锁
  - 多个线程公用一把锁
  - 共享数据，多个线程共同操作数据，即为共享数据。需要使用同步机制将操作共享数据代码包起来，不能包多了，也不能包少了。

## 解决线程安全问题三种：

- 同步代码块
- 同步方法
- lock（ReentrantLock）

## 线程池四种拒绝策略？默认哪种？



## 线程池参数几个？



## 线程池实现机制？

## 线程池计算问题

30个任务，核心线程数5个，非核心线程数5个，队列10个，拒绝线程数10个。

![img](https://mmbiz.qpic.cn/mmbiz_png/qhRZNwUg1HCJlr6YAapFWHTdy7RJvnCPwLNFs9d0EzCdt8W9MIzIBHPduKtogc4OEKencfeFzK7j2pJHYlbuEQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 定时线程池



## 线程池原理

线程池最常用 实际开发中 （类似于数据连接池）

- 提前创造好多个线程，放到线程池中，用时获取，用完放回去。避免浪费，类似公交

  优点：

  提高响应速度

  降低资源消耗

  便于线程管理



## 多线程程序的优点：

- 提高应用程序响应

- 提高计算机系统CPU利用率

- 改善程序结构，将既长又复杂进程分为多个线程，独立运行，方便理解修改

  

## Thread下的方法和优先级：

**Thread的方法**

1. start() 启动当前线程，调用当前线程的run();
2. run() 通常需要重写Thread类中此方法，将创建的线程要执行的操作写在此方法中
3. currentThread() 静态方法，返回执行当前代码的线程
6. yield() 释放当前cpu执行权
7. join() 在线程a中调用b的join()方法，此时线程a进入阻塞状态，知道b执行完结束
8. sleep(long millitime) 当前线程睡眠指定毫秒，在此之前线程处于阻塞状态
9. isAlive 判断当前进程是否存活
  

**Thread的优先级**
优先级：
MAX_PRIORITY = 10	//优先级高，优先运行权高，高概率被执行
MIN_PRIORITY = 1
NORM_PRIORITY = 5
方法：
getPrioirty();
setPrioirty(int p);

## 线程的生命周期

新建 就绪 运行 阻塞 死亡

新建 + start() = 就绪
运行 + 执行完run()/调用stop()/出现Error/Exception但不处理 = 死亡
运行 + sleep(long time)/join()/等待同步锁/wait()/suspend() = 阻塞
阻塞 + sleep()时间到/join()结束/获取同步锁/notify()、notifyAll()/resume() = 就绪

## 线程死锁

不同线程分别占用对方需要同步资源不放弃，都在等自己需要的同步资源

出现死锁后，不会报异常，不会出现提示，只是所有进程在阻塞状态

jstack调试工具可以解决

## synchronized 和 lock/unlock区别

lock需要手动启动同步，解锁也要手动实现

synchronized机制执行完相应同步代码块，自动释放锁

建议首选 lock -> 同步代码块 -> 同步方法

## 线程通信三种：

wait() :一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器

notify():一旦执行此方法，就会唤醒wait()的另一个进程，如果有多个，就唤醒优先级高的；

notifyAll():一旦执行此方法，唤醒所有线程

说明：

1. 只能用在同步代码块或者同步方法中，不能是lock

2. wait, notify, notifyAll 三个方法调用者必须是同步代码块或同步方法中的同步监视器，否则会出现异常

3. wait, notify, notifyAll 不是定义在Thread类里面，而是Object里面

## sleep和wait方法异同

相同点：都可以让当前线程进入阻塞状态

不同点：lock不能用wait

|              |   sleep    |       wait       |
| :----------: | :--------: | :--------------: |
| 对象方法调用 | Thread调用 |    Object调用    |
|   调用位置   |  任何位置  | 同步代码块或方法 |
|   锁的释放   |   不释放   |       释放       |



## start和run区别

1. start、run层次不同
2. 用start方法来启动线程，并没有运行，一旦得到cpu时间片，就开始执行run()方法
3. 这里方法run()执行线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止

start方法可启动多线程
run方法只是thread的一个普通方法调用执行，是不会开启多线程的

## i++是线程安全的吗？

局部变量肯定是线程安全的
成员变量多个线程共享时，就线程不安全的。

## ArrayBlockingQueue 和 LinkedBlockingQueue

ArrayBlockingQueue：一个由数组构成有界阻塞队列

LinkedBlockingQueue：一个由链表构成有界阻塞队列

阻塞队列不可用时，提供以下四种处理方式：

![img](https://pic1.zhimg.com/v2-c74eeb60c59fc147bba73bd80d84ac44_b.jpg)

## 你对锁和共享数据的理解及各自要求

锁：任何一个类的对象可以充当锁，多个线程公用一把锁

共享数据：多个线程共同操作数据，即为共享数据。需要使用同步机制将操作共享数据代码包起来，不能包多了，也不能包少了。

## CompletableFuture，这个是JDK1.8里的新特性，通过它怎么实现多线程并发控制？Future 和 FutureTask

```java
//ExecutorService新建线程池，新建一个操作（类，如果要返回值Callable否则Runnable）
ExecutorService executor = Executors.newFixedThreadPool(3);
//T是上面操作给的泛型
Future<String> future = executor.submit(task); 
String html = future.get();
executor.shutdown(); 
```

Future异步操作方案：.get()会造成阻塞，while + .isDone()来判断是否释放。

[素材源头，廖雪峰Future](https://www.bilibili.com/video/av54953654?p=16)

## callable为什么runnable多线程强大

1. call可以返回值

2. callable是支持泛型的

3. call可以抛出异常，被外面的操作捕获，获取异常的信息

## fail-fast和CopyOnWriteArrayList

**fail-fast** 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件

以List为例，多个线程同时操作一个List报ConcurrentModification异常。

可以使用CopyOnWriteArrayList，多个线程获取同一个资源，只在修改时复制副本，并将地址返回。
用到ReentrantLock重入锁（可以递归），可重写COWMap。

适用场景，读多写少场景，比如白名单、黑名单、产品目录。

**fail-safe**：出现同时修改异常，备份数据，继续执行，所以叫safe。

# 锁相关问题

## 悲观锁

每次拿数据认为别人会修改，所以每次拿数据都上锁，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock都是悲观锁

适用多写



## 乐观锁

每次拿数据认为别人不修改，所以不上锁，但更新的时会判断在此期间别人是否更新该数据，可以使用**版本号机制**和**CAS算法**实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。原子变量类**AtomicStampedReference**就是使用了乐观锁的一种实现方式**CAS**实现的。

适用多读

乐观锁实现方法：
1. 版本号机制，加一个ver字段+时间戳
2. CAS算法

```
需要读写的内存值 V
进行比较的值 A
拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。
```

乐观锁的缺点：
1 ABA问题，用AtomicStampedReference类可以解决
2 循环时间开销大，CAS一直不成功影响CPU性能
3 只能保证一个变量原子操作，多读场景用synchronized

**总结**：

1. 线程冲突轻，自旋容易成功，用CAS（CPU硬件实现，不用切线程）
2. 线程冲突重，用synchronized，用CAS大概率失败

## ConcurrentHashMap：

**jdk1.7** 分段锁技术，Segment+HashEntry（volatile修饰value和next）

Put方法：自旋获得锁，如果超过最大次数，改为阻塞锁获取。

Get方法：直接定位Segment和HashEntry

**jdk1.8** 采用了 `CAS + synchronized` 来保证并发安全性

HashEntry变成Node。
上锁前，操作都是基于volatile和CAS之上无锁且线程安全。

**读取** **操作** **判断是否改变** **执行操作**，这是用了CAS思想。

## 锁升级

4种状态：**无锁**、**偏向锁**、**轻量级锁状**、**重量级锁（悲观锁）**

没有任何线程访问时，它是可偏向的，只能有一个线程来访问它，当第一个线程来访时，它会偏向这个线程，此时，对象持有偏向锁偏向第一个线程。第二个线程访问，如果第一个线程结束，回到无锁和偏向状态，否则进入轻量级锁。

轻量级锁，一个持有线程，一个自旋，又有第三个来访，则变成重量级锁。或者自旋超过某个次数。

## volatile
保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（**可见性**）
禁止进行指令重排序。（**有序性**）
volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证**原子性**。

原子性：程序中操作要么全部完成,要么全部不完成,不可能停滞在中间某个环节，volatile 修饰的变量读写都有原子性

可见性，有序性：两个一起说，happens-before关系来保障可见性描述有序性。java内存模型的动作包括读/写，锁的申请与释放，线程的启动等待释放。这些动作就是用来保障h-b特性。假设A和B之间存在happen-before 关系，那么java 内存模型保证A的操作结果对B可见。在这里我解释以下为什么能从可见性来描述有序性呢？因为A，B线程中 A先于B线程执行，然后线程B能够看到线程A的执行过程的结果，就默认 线程A的执行时具有有序性的，不管线程A中他的执行顺序是如何。

## AQS

**AbstractQueuedSynchronizer，抽象队列同步器**

JUC一个核心组件，有state变量、加锁线程、等待队列等核心，维护了加锁状态。

# Mybatis

## 什么是Mybatis？

1、Mybatis 是一个**半ORM框架**，它内部**封装JDBC**，开发时**只关注 SQL** 语句本身
不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接**编写原生态 sql**，可以严格**控制执行性能**， 灵活度高。

2、使用 **XML** 或**注解**来配置和映射原生信息， 将 **POJO 映射**成**数据库记录**
避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

3、通过 **XML** 或**注解**的方式配置**statement** ， 并通过**java 对象**和 **statement 中 sql 的动态参数**进行映射成 **sql 语句**，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。

## Mybaits 的优点：

1、SQL 编程，相当灵活，不会对程序或者数据库的设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序的耦合，便于管理；提供 XML 标签， 编写动态 SQL 语句， 并可重用。

2、消除了 JDBC 大量冗余的代码，不用手动开关连接；

3、与多种数据库兼容，MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。

4、Spring 很好集成；

5、提供映射标签， 支持对象与数据库的 ORM 字段关系映射；提供对象与关系映射标签， 支持对象关系组件维护。

## MyBatis 框架的缺点：

1、SQL 编写量大， 当字段多、关联表多时， 编写SQL 要求高

2、SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。

## MyBatis 框架适用场合：

1、MyBatis 专注于 SQL 本身， 是一个足够灵活的 DAO 层解决方案。

2、对性能的要求很高，或者需求变化较多的项目，如互联网项目， MyBatis 将是不错的选择。

## #{}和${}的区别是什么？

**#{}是预编译处理， ${}是占位符替换。**

Mybatis 在处理 #{} 时，就是把 {} 中 替换为字符串（加双引号），调用 PreparedStatement 的set 方法来赋值；

Mybatis 在处理 ${} 时，就是把 {} 中替换成变量的值。占位符

使用 #{} 可以有效的防止 SQL 注入， 提高系统安全性。

## 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

第 1 种：通过在查询的 sql 语句中定义字段名的别名， 让字段名的别名和实体类的属性名一致。

```xml
<select id=”selectorder”  parametertype=”int”  resulttype=” me.gacl.domain.order”>
		select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};
</select>
```

第 2 种：通过来映射字段名和实体类属性名的一一对应的关系。

```xml
<select id="getOrder" parameterType="int" resultMap="orderresultmap">
		select * from orders where order_id=#{id}
</select>
<resultMap type=”me.gacl.domain.order”  id=”orderresultmap”>
    <!–用 id 属性来映射主键字段–>
    <id property=”id”  column=”order_id”>
    <!–用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性–>
    <result property =  “orderno”  column =”order_no”/>
    <result property=”price”  column=”order_price”  />
</reslutMap>
```

## Mybatis 的一级、二级缓存:

1）  一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存， 其存储作用域为Session， 当 Session flush  或  close  之后， 该  Session  中的所有  Cache  就将清空， 默认打开一级缓存。

2） 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)， 并且可自定义存储源， 如 Ehcache。

setting cacheEnabled 值设为true
在sql语句中用flushCache或者useCache避免脏读

默认不打开二级缓存， 要开启二级缓存， 使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置

3）  对于缓存数据更新机制， 当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 。

## Mapper 配置有哪几种方式？

第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口， mapper 接口实现类、mapper.xml 文件。

1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置

```xml
<mappers>
<mapper resource="mapper.xml 文件的地址" />
<mapper resource="mapper.xml 文件的地址" />
</mappers>
```

2、定义 mapper 接口

3、实现类集成 SqlSessionDaoSupport

mapper 方法中可以  this.getSqlSession()进行数据增删改查。

4、spring 配置

```xml
<bean id=" " class="mapper 接口的实现">
<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>
```

第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：

1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置， 如果 mapper.xml 和mapper接口的名称相同且在同一个目录， 这里可以不用配置

```xml
<mappers>
<mapper resource="mapper.xml 文件的地址" />
<mapper resource="mapper.xml 文件的地址" />
</mappers>
```

2、定义 mapper 接口：

- mapper.xml 中的 namespace 为 mapper 接口的地址

- mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致

- Spring 中定义

```xml
<bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
<property name="mapperInterface" value="mapper 接口地址" />
<property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>
```

第三种：使用 mapper 扫描器：

1、mapper.xml 文件编写：

mapper.xml 中的 namespace 为 mapper 接口的地址；

mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；

如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml 中进行配置。

2、定义 mapper 接口：

注意 mapper.xml 的文件名和 mapper 的接口名称保持一致， 且放在同一个目录

3、配置 mapper 扫描器：

```xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
<property name="basePackage" value="mapper 接口包地址"></property>
<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
</bean>
```

4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。

## 什么是 MyBatis 的接口绑定？有哪些实现方式？

接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。

接口绑定有两种实现方式,
一种是通过注解绑定， @Select、@Update 等注解， 注解包含 Sql 语句；
另外一种就是通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名，id值是方法名。SQL 简单时,用注解绑定, SQL 复杂时,用 xml 绑定,一般用 xml 绑定的比较多。

## 使用 MyBatis 的mapper 接口调用时有哪些要求？

四大相同

|  Mapper接口  |      mapper.xml       |
| :----------: | :-------------------: |
|    方法名    |        sql的id        |
| 输入参数类型 | parameterType类型相同 |
| 输出参数类型 |  resultType类型相同   |
|   文件路径   | mapper标签的namespace |

## 通常一个Xml 映射文件，都会写一个Dao 接口与之对应，请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法， 参数不同时，方法能重载吗？

Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名， 就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数， 就是传递给 sql 的参数.

Mapper 接口是**没有实现类**的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值， 可唯一定位一个 MapperStatement。在 Mybatis 中， 每一个
select、insert 、update、delete标签，  都会被解析为一个MapperStatement 对象.
举例：com.mybatis3.mappers.StudentDao.findStudentById， 可以唯一 找 到 namespace 为 com.mybatis3.mappers.StudentDao 下 面 id 为findStudentById 的 MapperStatement 。
Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理， Mybatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy， 代理对象会拦截接口方法， 转而执行 MapperStatement 所代表的 sql， 然后将 sql 执行结果返回。

## MyBatis 实现一对一、一对多、多对多？

有联合查询和嵌套查询

联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成；

```xml
<!--	建立表和实体类之间映射-->                                                           
	<resultMap id="menuMap" type="Menu">                                         
		<id column="id" property="id"></id>                                      
		<result column="name" property="name"></result>                          
		<result column="price" property="price"></result>                        
		<result column="flavor" property="flavor"></result>                      
		<association property="type"                                             
			select="com.southwind.repository.TypeRepository.findById"            
			column="tid">                                                        
		</association>                                                           
	</resultMap>                                                                     
```

嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。

## Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？

答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载， association 指的就是一对一， collection 指的就是一对多查询。在 Mybatis 配置文件中， 可以配置是否启用延迟加载  lazyLoadingEnabled=true|false。

它的原理是， 使用 CGLIB 创建目标对象的代理对象， 当调用目标方法时， 进入拦截器方法， 比如调用 a.getB().getName()， 拦截器 invoke()方法发现 a.getB()是null 值， 那么就会单独发送事先保存好的查询关联 B 对象的 sql， 把 B 查询上来， 然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。

当然了， 不光是 Mybatis， 几乎所有的包括 Hibernate， 支持延迟加载的原理都是一样的。

## Mybatis 动态sql 有什么用？执行原理？有哪些动态sql？

Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。

## Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？

答：Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose

| when | otherwise | bind ， 加上动态 sql 的 9 个标签， 其中为 sql 片段标签， 通过

标签引入  sql  片段，为不支持自增的主键生成策略标签。

## Mybatis 的 Xml 映射文件中， 不同的 Xml 映射文件， id 是否可以重复？

不同的 Xml 映射文件， 如果配置了 namespace， 那么 id 可以重复；如果没有配置 namespace， 那么 id 不能重复；原因就是 namespace+id 是作为 Map的 key 使用的， 如果没有 namespace， 就剩下 id， 那么， id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。

## Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

第一种是使用标签， 逐一定义数据库列名和对象属性名之间的映射关系。

第二种是使用 sql 列的别名功能， 将列的别名书写为对象属性名。

有了列名与属性名的映射关系后， Mybatis 通过反射创建对象， 同时使用反射给对象的属性逐一赋值并返回， 那些找不到映射关系的属性， 是无法完成赋值的。

## 如何获取自动生成的(主)键值?

insert 方法总是返回一个 int 值 ， 这个值代表的是插入的行数。

如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。

示例：

```xml
<insert id=”insertname”  usegeneratedkeys=”true”  keyproperty=” id”> 
	insert into names (name) values (#{name})
</insert>
```

```java
name name = new name(); name.setname(“fred”);
int rows = mapper.insertname(name);
// 完成后,id 已经被设置到对象中system.out.println(“rows inserted =  ”  + rows);
system.out.println(“generated key value =  ”  + name.getid());
```

## 在 mapper 中如何传递多个参数?

1、第一种：DAO 层的函数

public UserselectUser(String name,String area);

对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二参数，更多参数一致往后加即可。

```xml
<select id="selectUser"resultMap="BaseResultMap"> select * fromuser_user_t whereuser_name = #{0} and user_area=#{1}
</select>
```

2、第二种：使用 @param 注解:

```java
public interface usermapper {
user selectuser(@param(“username”) string username,@param(“hashedpassword”) string hashedpassword);
}
```

然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给mapper):

```xml
<select id=”selectuser”  resulttype=”user”> select id, username, hashedpassword from some_table
where username = #{username}
and hashedpassword = #{hashedpassword}
</select>
```

3、第三种：多个参数封装成 map

```java
try {
//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的
SQL
//由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此我们使用 Map 集合来装载我们的参数
Map < String, Object > map = new HashMap(); map.put("start", start);
map.put("end", end);
return sqlSession.selectList("StudentID.pagination", map);
} catch (Exception e) { e.printStackTrace(); sqlSession.rollback(); throw e;
} finally {
MybatisUtil.closeSqlSession();
}
```

sqlsession 线程不安全

## MyBatis延迟加载

**减少 Java 应⽤用与数据库的交互次数**延迟加载也叫懒加载、惰性加载，使⽤延迟加载可以提⾼高程序的运行效率，针对于数据持久层的操作， 在某些情况下可以不访问某些表，一定程度上减少了了 Java 应⽤用与数据库的交互次数。

>查询学⽣生和班级的时，学⽣生和班级是两张不不同的表，如果当前需求只需要获取学⽣生的信息，那么查询学
>⽣生单表即可，如果需要通过学⽣获取对应的班级信息，则必须查询两张表。
>不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的⼯工作就是延迟加载。

在 config.xml 中开启延迟加载

将级联查询sql语句拆分成两个不同sql语句，对应两个不同方法。

**Mybatis优化**：**MyBatis** 缓存 什什么是 MyBatis 缓存

使⽤用缓存可以**减少 Java 应⽤用与数据库的交互次数**，直接从缓存中取出对象即可， ⽆无需再次访问数据库。

MyBatis 缓存分类
1、一级缓存:SqlSession 级别，默认开启不能关闭。

2、⼆级缓存:Mapper 级别，默认关闭，可以开启。多个 SqlSession 使⽤同⼀个缓存。可以用Mybatis自带缓存，也可以使用第三方。
**Mybatis动态SQL语句**
使用动态sql语句可以减少代码开发，程序自动通过业务逻辑

1. where和if标签

```xml
<select id="findByAccount" parameterType="com.southwind.entity.Account" resultType="com.southwind.entity.Account">
  select * from t_account
  <where>
    <if test="id!=0">
      id = #{id}
    </if>
    <if test="username!=null">
      and username = #{username}
    </if>
    <if test="password!=null">
      and password = #{password}
    </if>
    <if test="age!=0">
      and age = #{age}
    </if>
  </where>
</select>
```

2. choose和when标签
3. trim标签中的prefix和suffix都会被用于标签内部的拼接
4. foreach标签可以生成一系列值，主要用于生成sql的in语句

---

46 Mybatis笔记及如何优化
ORMapping: Object Relationship Mapping 对象关系映射 对象指⾯向对象
关系指关系型数据库
Java 到 MySQL 的映射，开发者可以以⾯向对象的思想来管理数据库。

- config.xml

配置Mybatis综合信息。

environments对应一个schema，可以配置多个schema。DataSource标签配置数据连接池，包括账户密码、驱动包和url等。

Mappers配置其他sql语句关联的xml文件，几个类或者接口，几个xml。

**通过 Mapper 代理理实现⾃定义接⼝**业务中最为常用的创造实体类方法。sqlSession.getMapper

```java
AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class);
```

增删改查分别对应接口不同方法。尤其是查，往往存在多个方法，按id，按名字，按学号等等。
同时int类型往往还需要复写Integer包装类。

此外，如果多个表关联查询，比如同时查学号和班级。需要用resultMap间接映射，此时不能直接映射。

```xml
<resultMap id="studentMap" type="com.southwind.entity.Student">
  <id column="id" property="id"></id>
  <result column="name" property="name"></result>
  <association property="classes" javaType="com.southwind.entity.Classes">
    <id column="cid" property="id"></id>
    <result column="cname" property="name"></result>
  </association>
</resultMap>
<select id="findById" parameterType="long" resultMap="studentMap">
  select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where s.id = #{id} and s.cid = c.id
</select>
```

**多对多关系**：两张主表 一张从表 （包含被两个主表约束的外键）

|  id  | cid  | gid  |
| :--: | :--: | :--: |
|  1   |  1   |  1   |
|  2   |  1   |  3   |
|  22  |      |  2   |

```xml
<select id="findById" parameterType="long" resultMap="customerMap">
	select c.id cid,c.name cname,g.id gid,g.name gname from customer c,goods g,customer_goods cg           		where c.id = #{id} and cg.cid = c.id and cg.gid = g.id
</select>
```

|                 nginx                 |       apache httpd       |
| :-----------------------------------: | :----------------------: |
|    支持异步功能，不过是阻塞性异步     |       非阻塞性异步       |
|               体量很小                |          体量大          |
| 消耗资源少，抗并发能力强，3倍于apache | 消耗资源多，抗并发能力弱 |
|      反向代理负载均衡，静态服务       |        静态+动态         |
|              HTTP Server              |       HTTP Server        |

|            nginx             |                    tomcat                     |
| :--------------------------: | :-------------------------------------------: |
|         HTTP Server          |        Application Server/Servlet 容器        |
| 反向代理(负载均衡)，静态服务 | 动态内容转静态内容，通过HTTP Server转发客户端 |

# Tomcat

## Tomcat有几种部署方式？

1. 直接把web项目war包放在**webapps**下，Tomcat会自动将其部署；

   ```xml
   <Host xmlBase="/home/app/context" name="localhost" appBase = "webapps" …></Host>
   ```

2. 在server.xml文件上配置节点，设置相关的属性即可，放在**WebContent**下

   ```xml
   <Context Path="/jstore"Docbase="C:\work\jstore\WebContent" Debug="0" Privileged="True" Reloadable="True"></Context>
   ```

3. 通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，新建一个xml文件，名字不可以随意取，要和path后 的名字一致，我这里就应该是jstore.xml文件，它的具体内容为：

   ```xml
   <Context docBase="C:\work\jstore\web" path="/jstore" reloadable="true"/>
   ```

## Tomcat的默认端口是多少，怎么修改？

默认端口8080，修改server.xml标签

1. Tomcat目录下conf文件夹，打开server.xml

2. 在server.xml文件里面找到下列信息
  
  ```xml
  <Service name="Catalina">
  <Connector port="8080" protocol="HTTP/1.1"
  connectionTimeout="20000"
  redirectPort="8443" />
  ```
  
3. 把port=”8080″改成port=”8888″，并且保存

4. 启动Tomcat，并且在IE浏览器里面的地址栏输入[http://127.0.0.1:8888/](http://127.0.0.1:8888/)

# Nginx

是一个高性能的HTTPweb服务器，可用作反向代理，部署静态资源。

## Nginx有哪些用途？

1. 反向代理：负载均衡，故障转移，解决跨域
2. 静态资源缓存
3. 服务器限流(Nginx+lua+openresty)、漏桶算法/令牌桶算法
4. 防止ddos攻击、黑白名单等，因为Nginx是我们服务器入口。

## 基于nginx解决网站动静分离
1. 基于nginx实现动静分离，nginx放置img、css、js和html等静态资源
2. 使用第三方静态资源服务器 oss、七牛云收费的服务器
3. 互联网公司项目中很少采用nginx实现动静分离，因为不支持CDN

## 怎么设置work数量或work_process?

每个worker一个独立进程,worker数量和服务器cpu数量匹配最为适宜

## nginx的worker_connection的设置?

2（静态，对client）或者4（对client和tomcat），因为需要client来回，tomcat来回。

## nginx一个master和四个worker，每个worker支持最大连接数是1024，支持最大并发数是多少？

- 静态连接：work_connection * work_process /2
- 反向代理：work_connection * work_process /4

## 补

1. 反向代理方面，nginx的基本配置，比如如何通过lua语言设置规则，如何设置session粘滞。如果可以，再看些nginx的底层，比如协议，集群设置，失效转移等。
2. 使用nginx静态资源压缩实现原理
3. 使用nginx缓存静态页面设计思想
4. openresty+lua：开源，国人，可伸缩强大web应用服务器，支持多种第三方模块，使用C以及lua模块，性能强

# 相似名词


抽象类不能实例化自身，接口也不能实例化，只能实现。

抽象类和接口区别：
抽象类：对一类事物的抽象，规定属性和行为(可以写方法)，目的是复用
接口：对某一行为抽象，只有声明，仅仅约束行为

开发者继承抽象类是为了使用抽象类的属性和行为; 开发者实现接口只是为了使用接口的行为.

“抽象级别（从高到低）：接口>抽象类>实现类”
类都是单继承，但可以实现多个接口。

抽象类里面的抽象方法必须全部被子类实现,如果子类不能全部实现,那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。

抽象类里面可以没有抽象方法。

- 接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。

抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。

人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。



程序是静态代码，进程是运行中的程序，线程是进程里面一条独立执行路径

**什么是session、token、cookies**
	1）最早web就是浏览静态文档图片，不用交互
	2）记住会话，哪些人浏览网站、加了购物车，一个session id字段，服务端能分清楚谁是谁
			但是多个服务器集群需要session存储记住所有人的id
	3）token令牌，由服务器发给用户，用户访问时候将令牌和id一起传过来，通过Http header，SHA256算法验证签名和token，避免存储session
	4）cookie 是浏览器里永久存储的数据，cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用

**execute**与**executeUpdate**的相同点：都可以执行增加，删除，修改

statement 对象的方法 传入sql的命令构成字符串 就能远程操作数据库

不同点：

1：
execute**可以执行查询语句**
然后通过getResultSet，把结果集取出来
executeUpdate**不能执行查询语句**
2:
execute**返回boolean类型**，true表示执行的是查询语句，false表示执行的是insert,delete,update等等
executeUpdate**返回的是int**，表示有多少条数据受到了影响

try with resource ——可以自动关闭链接资源
try(){

}catch(){

}

1. ConnectionPool() 构造方法约定了这个连接池一共有多少连接

2. 在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用

3. getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去

4. returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了。

注：连接池设计用到了多线程的wait和notifyAll

**并行：**多个cpu干多件事
**并发：**一个cpu同时执行多个任务，秒杀等

**方法重写：**子继承父	子重写覆盖父亲
**方法重载：**相同方法名，有不同参数列表

**Collection：**单列集合接口，有List和Set，定义一些规范
**Collections：**是针对集合操作的工具类，操作Collection和Map的工具类，其中包含对集合进行排序和二分查找的方法

**int与Integer 的区别？**
int是Java语言提供的八种原始数据类型之一，当作为对象的属性的时候，默认值为0

Integer是Java为int提供的包装类，默认值为null。

int是基本类型,在使用的时候采用的是值传递。

Integer采用的是引用传递。

当往容器里存放整数的时候，无法直接存放int 而是将int类型转换为Integer存放。


**URL和URI区别？**

URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的

URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
URL是Internet上用来描述信息资源的字符串，主要用在各种客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。
 而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。
URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等

**throw和throws区别**
1、throw代表动作，表示抛出一个异常的动作；throws代表一种状态，代表方法可能有异常抛出
2、throw用在方法实现中，而throws用在方法声明中
3、throw只能用于抛出一种异常，而throws可以抛出多个异常

throws声明异常
throw抛出异常
try/catch/finally

- 比较throw和throws区别

- - throw：生成一个异常对象，并抛出。方法内部<-->自动抛出异常对象
  - throws：处理异常方式，<--> try - catch - finally
  - "上游排污，下游治污"

**final  finally  finalize 的区别？**
final：类 不能继承，方法 不能重写，变量 不能修改
特：反射可以改变final性质

finally try/catch语句块，无论如何被执行，除了几种特殊情况
关闭资源，释放锁

finalize()定义在java.lang.object中方法
垃圾回收前调用，对象回收前释放资源
每个finalize()只会被GC调用一次

**Override 和Overload的区别是什么？Overload的方法是否可以改变返回值的类型？**
Overload（重载）和Override（覆盖）是java多态性的不同表现，其中，重载是在一个类中多态性的一宗表现，是指在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型。在使用重载时，需要注意:

1重载时通过不同的方法参数来区分的，

2 不能通过方法的访问权限，返回值类型和抛出的异常来进行重载。

3对于继承类来说，如果基类方法的访问权限是private，那么就不能在派生类中对其进行重载，如果派生类也定义了一个同名函数，这只是一个新的方法，不会达到重载的作用。

Override 是指派生类函数覆盖基类函数，覆盖一个方法并对其进行重写，以达到不同的作用。

在使用覆盖的时候需要注意。

派生类的覆盖方法必须和基类中的覆盖方法有相同的函数名和参数。

派生类中的覆盖方法的返回值必须和基类中的被覆盖方法的返回值相同。

派生类的覆盖方法所抛出的异常，必须和基类中被覆盖方法所抛出的异常一致或者是他的子类。

重载与覆盖之间的区别主要有以下几个方面：

1覆盖是子类和父类之间的关系，是垂直关系。重载时同一个类中方法之间的关系。是水平关系。

覆盖只能由一个方法或只能由一对方法产生关系；方法的重载是多个方法之间的关系。

覆盖要求参数类表相同，重载要求参数列表不同。

覆盖关系中，调用方法体是根据对象的类型（对象对应的存储空间类型）来决定的；而重载关系是根据调用时的实际参数与形参列表来选择方法体的。

如果一个类中定义的多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为重载方法。Overload的方法是可以改变返回值的类型，但是Override 的方法不能改变返回值的类型。

**Comparable与 Comparator的区别？**
上面提到了Comparator排序，很多面试题里都问到 Comparable 与Comparator的区别。

个人总结这两个接口之间的区别：  

Comparable 是自然排序。让元素自身具备“比较性”。覆盖int compareTo(T o)方法。

Comparator  是定制排序。提供一个比较器，一些集合调用比较器来比较集合中俩个元素。要覆盖int compare(T o1,T o2)方法。

Comparable之所以称之“自然排序”是因为很多java.lang的常用类都实现了这个接口。

基础数据类型包装类  排序规则 ：按他们对应数值的大小进行排序

Character 按字符转换的Unicode数值进行排序。

Boolean 中 true 对应的数值大于false对应的。

String  按字符串转化成的Unicode数值进行排序。

Date  Time 后面的时间比前面的时间大。

TreeSet中两者的区别明显。

**forward和redirect的区别是什么？**
Forward是服务器内部的重定向，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，而客户端并不知道，因此，在客户端浏览器的地址栏里不会显示转向后的地址，还是原来的地址。由于整个定向的过程中用的是同一个Request，因此，forward会将Request的信息带到被定向的JSP或者是Servelet中使用。

Redirect则是客户端重新定向，是完全的跳转，即客户端浏览器会获取跳转后的地址，然后重新发送请求，因此，浏览器中会显示跳转后的地址。同时由于这种方式比forward方式多了一次网络请求，所以，forward效率更高。

**Synchronized和lock的区别？**
Synchronized关键字，每个对象都有一个对象锁与之相关，该锁表明对象在任何时候只允许被一个线程拥有，当一个线程调用对象的一段synchronized代码时，首先需要获得这个锁，然后去执行相应的代码，执行结束后，释放锁。

Synchronized关键字主要有两种用法， synchronized方法和synchronized块 此外关键字还可以作用于静态方法、类或某个实例，但这都对程序的效率有很大的影响。

只要把多个线程访问资源的操作放在一个标记Synchronized的方法中，就能够保证这个方法在同一时间只能被一个线程来访问，从而保证了多线程访问的安全性。然而，当一个方法的方法体规模非常大的时候，把该方法声明为synchronized会大大影响程序的执行效率。为了提高程序的执行效率，java语言提供了synchronized块

可以把任意代码段声明为synchronized，也可以指定上锁的对象，有非常高的灵活性。

Jdk5新增加了lock接口以及它的一个实现类ReentranLock（重入锁）lock也可以用来实现多线程的同步，具体而言，它提供了如下的一些方法

Lock()以阻塞的方式来获取锁，也就是说，如果获取了锁，则立即返回，如果其他线程持有锁，当前线程等待，直到获取锁后返回。

Trylock()以非阻塞的方式来获取锁，只是尝试地去获取一下锁，如果获取到锁，则立即返回true，否则，立即返回false；

Trylock（long timeout，timeunit unit）如果获取了锁，立即返回true 否则，会等待参数给定的时间单元，在等待的过程中，如果获取了锁，就返回true，如果等待超时，则返回false。

Lockinterrupttibly()、如果获取了锁，则立即返回，如果没有获取锁，则当前线程处于休眠状态，直到获取锁，或者当前线程被其他线程中断。


# Java基础

三种遍历
1 Iterator 迭代器方式
2 增强for循环
3 普通循环

- iterator() 三个方法 指向Collection第一个元素前面的元素

- - .hasNext()
  - .next()
  - .remove()

- .super关键字作用

- - 主要存在于子类方法中，用于指向子类对象中父类对象。
  - 访问父类的属性
  - 访问父类的函数
  - 访问父类的构造函数

- 什么是枚举类，枚举类对象声明修饰符有哪些？

- - 枚举类：类中对象个数是有限的，不能再增加，
  - 当用常量时候，建议用枚举类
  - 如果枚举类只有一个对象，则可用单例模式实现方式
  - 
  - private final(no 错的)
  - private static final(yes 是的）

- 什么是元注解？说说Retention 和 Target 元注解作用

- - 元注解：对现有注解进行解释说明的注解

  - Retention： 指明所修饰的注解的生命周期，SOURCE CLASS（默认） RUNTIME

    前提：要求此注解的元注解Retention中声明的生命周期状态为Runtime

- dataType[] arr; 建议这么写
- arr = new dataType[size];
- str.toUpperCase(); 这个方法不改变str，返回值变大写
- 克隆会产生多个对象的拷贝，类克隆一定要实现Cloneable接口
- str1==str2 是在判断两个字符串内存地址是否相等
- str.delete(1,3) 删除1到2（不包括3）字符
- str.split(";");  用；分割字符串
- java 不准参数设置默认值
- java不会传递对象，只对传递对象引用，按引用传递对象，数组也是引用传递，值才会传递
- 静态函数不能调用非静态函数
- public static void main（String[] args)
- if(x=y)编译不过
- 子类可以访问所有（子类和超类）的public和protected方法
- private 修饰方法与属性只能在同一个类访问
- java变量一定要初始化
- java类只能单继承，或者伪多继承
- 线程是一次性消耗品，执行run()方法后，线程结束后销毁。不能再次start，只能重新建立新的线程对象。
- runnable接口必须重写run()
- Java.Lang.throwable 所有异常的基类
- bool值不可与任何其他类型转化 或 比较
- 类和对象只是同一个东西不同名称，类是对象的模板，对象是类的具体实例
- list常用方法

```java
增 add(Object obj)

删 remove(Index value/Object obj)

改 set(int index, Object obj)

查 get(int index)

插 add(int index, Object obj)

长度 size()
```

- static随类加载而加载，可以修饰：属性，方法，代码块，内部类
- - final static 修饰全局常量和属性
- private 私有的new不了，也不能重写
- 抽象的父类，以至于他没有具体的实例，这样类叫做抽象类。
- 方法可以重写，构造器不能重写，只能重载
- 类是单继承的，接口实现多继承效果
- 接口只能定义全局常量和抽象方法，接口中不能定义构造器，意味着不可以实例化
- 接口只能通过类+implements方式使用
- 实现类实现了接口中的抽象方法

99 封装性

实际问题中，我们要给属性赋值加入额外的限制条件，这个条件不能在属性声明时体现，只能通过方法进行限制条件添加，我们要避免用户用对象给属性赋值。则我们需要将属性声明为私有的(private)，体现了封装性

  - 我们将xxx属性私有化，同时提供公共的方法来获取（getxxx）和设置（setxxx）

  - 扩展：封装性体现在，1如上 2不对外暴露私有的方法 3 单例模式

  - 封装性体现通过修饰符实现，四种权限(从小到大)：private < 缺省 < protected < public

  - 四种权限来修饰类及类内部结构：属性，方法，构造器，内部类

  - 修饰类只能用： 缺省 public

    

- 可变参数的方法

```java
public void show(String ... strs){ //可变形参，只能有一个，写在列表最后面
	把strs当字符串数组处理即可
}
```

- 同时保留public void show(String strs){}

65 final修饰类，属性可修改吗？
基础数据类型，final修饰肯定不变		
引用数据类型，final修饰引用地址不变，内容不变——String、StringBuffer、ArrayList、HashSet、HashMap等。

final最终的

- 1 final 可以用来修饰结构：类，方法，变量
- 2final用来修饰一个类，不能被其他类继承
  - - 比如：String、System、StringBuffer类

  - 3final用来修饰方法，表明此方法不可以被重写

  - - 比如：Object中的getClass()

  - 4final变量

  - - 修饰属性，可以显示初始化/代码块初始化/构造器初始化赋值一次，且只可赋值一次
    - 修饰局部变量，尤其是修饰形参时，表明此形参是一个常量，当我们调用方法时，给常量形参赋一个实参

​    一旦赋值以后，就只能使用不能修改



![img](https://img-blog.csdn.net/20180607221353561)

八种基本类型：[int short long] bool byte double

![img](https://pic4.zhimg.com/v2-a4de2da2942089375382858919e3ae63_b.png)

70 String类为什么是final类型

答：

- 为了实现常量池(只有当字符是不可变的，字符串池才有可能实现)
- 为了线程安全(字符串自己便是线程安全的)
- 为了实现String可以创建HashCode不可变性
- 为了安全性和效率，地址不变值可变



String相关内容

>String创建不变对象，被多线程访问保持一致性
>创建后，常量池缓存，有新的相同字符串返回缓存引用
>final：不可被继承，提升安全性

> == 		判断两个String是不是相同地址
> equals   判断两者是否相等值


>系统内存分为四个：
>heap 堆 放 对象 也就是new 出来的东西
>stack 栈 放局部变量
>static segment 静态区 用来放 **静态变量** 和**字符串常量**
>data segement 代码区 用来放代码的
>
>如果 一个字符串是 String s = "abc";它放在栈里
>如果一个字符串 用创建对象的方式 String s = new String("abc");
>那它是放在了 堆里 而如果单纯的 一个 "abc" 这个输入[字符串常量](https://www.baidu.com/s?wd=字符串常量&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) 是放在static segement里

1) 讨论字符串相等与否

String a = "123"; String b = "123"; a==b的结果是什么？ 这包含了内存，String存储方式等诸多知识点。

> a和b指向同一个对象，地址相同数据相同 --> **true**

String a=new String("Hello");String b=new String("Hello");

> a和b指向不同对象，地址不同数据相同-->**false**

> 以上两个都a.equals(b)都是-->**ture**

> StringBuilder:		不安全	 高		可变								单线程大数据
> StringBuffer:		  安全		中		可变								多线程大数据
> String:				   安全 	    低	   不变（不同的生成新的）少量数据

hashMap怎么解决hash碰撞

1. 开放地址法，+di序列，再去探测没有用的槽
2. 再hash法，准备多个hash函数
3. 链地址法，每个节点存一个链表，同key的链表，1.8后就是用链表+红黑树来解决

42 HashMap里的hashcode方法和equal方法什么时候需要重写？如果不重写会有什么后果？对此大家可以进一步了解HashMap（甚至ConcurrentHashMap）的底层实现。

> equal指向地址是否相同(内部==比较运算符)，如果判断值是否相同需要重写
>
> hashcode返回地址的散列hash，如果散列不同
> hashcode在HashMap和HashSet必须重写，因为插入、删除不能是散列的值
>
> 如果hash值相同放到同一个bucket里面，

>hashcode和equals必须同时重写，
>自定义对象作为Map键，必须重写以上的两项

> 散列哈希+链表/红黑树（超过阈值）
> concurrentHashMap 加了**synchronized**，保证put/get方法

>hashCode作用
>
>返回对象的哈希代码值，散列码，支持哈希表
>提高哈希表性能

HashMap:

>存储结构：数组+链表+红黑树
>容量：16
>装载因子：0.75
>Key/Value：泛型	key可为null -> table[0]
>hashCode：计算键的hashCode查找对象存储位置
>equals：hashMap判断键与表中键是否相等

71 HashMap底层数据结构及原理

- 数组+链表+(1.8增加了 红黑树)
- 搞懂hashCode作用
- put和get的过程
- hash冲突是什么

  1. 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
  2. put存时，如果出现hash值相同的key，此时有两种情况。
     a :如果key相同，则覆盖原始值；b: 如果key不同（hash冲突啦），则将当前的key-value放到链表中
  3. get获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。
  4. HashMap是如何解决hash冲突问题（数组+链表），核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。

84Map种类及区别

HashMap 非线程安全
ConcurrentHashMap 线程安全

并发情况：
ConcurrentHashMap和HashTable
两者hash计算公式不同，后者不用红黑树
前者用CAS算法保证，后者用synchronized+代码块

顺序Map实现类：LinkedHashMap(进入顺序)和TreeMap（数据大小顺序）

---

HashMap和Vector静态集合类持续添加使用；
释放对象时候要删除监听器；
数据库 网络连接没有关闭；
单例模式，单例对象持有外部对象引用，不能GC。

43 ArrayList和LinkedList底层实现有什么差别？它们各自适用于哪些场合？对此大家也可以了解下相关底层代码。

> 都是线程不安全的，继承了Cloneable List Serializable接口
> ArrayList是数组，查找快
> LinkedList是循环双向链表，删除增加快

89 ArrayList的SubList方法返回值不是ArrayList，是内部类SubList。

99 linkedlist用iterator
arraylist用for，可以随机存储，可索引访问

58 安全删除遍历ArrayList一个元素？
快速失败机制，不要用foreach 删/增 （remove/add）
用iterator模式的remove，若并发还要加对象锁

56 Object常见方法
toString()	hashCode()	equals()	wait()	notify()

59 迭代器：不同集合提供统一的遍历操作接口

44 volatile关键字有什么作用？由此展开，大家可以了解下线程内存和堆内存的差别。

> 是一个类型修饰符。volatile修饰的变量具有可见性，即保证线程读取到的是最新更新的值。线程不拷贝内存变量而是直接读取内存中的变量，当内存中变量被其他线程修改后线程能立马知道。同步是锁定变量，只允许一个线程对其进行操作，是原子性动作。volatile修饰不一定是线程安全的。
>
> 某共享变量，每个线程都缓存一个该变量的副本。当一个线程更新其副本(高速缓存区)时，其他的操作单元可能没有及时发现，进而产生缓存一致性问题。
>
> JMM内存模型，堆内存上面叠放线程内存，每次都打到底，改了也会去更新别的线程内存的副本。

94 HashMap实现

 jdk7 底层 数组+链表；

jdk8 底层 数组+链表（装树的根）+红黑树（左小右大）



51 枚举使用场景，某个字段有几个不同取值，在写foreach用。

---

- 通过一个对象的引用访问静态成员属性或者方法时 ，访问操作只与所声明的引用类型相关 ；与引用对象是否为 null 无关 ，因为访问静态成员不需要实例化对象 ；即便引用不为 null ，也与运行时多态无关 ，因为静态成员是类相关的 。

---

jdk 8 中注解新特性，可重复注解，类型注解

1. 可重复注解

2. 类型注解

注解就是类中的特殊标记，反射中读标记，在编译，类加载，运行时读取



**类初始化顺序**
静态变量 静态初始化块
变量 初始化块
构造器
先父后子

# Restful API

31 restful
https://www.jianshu.com/p/ee92c9accedd

五种http请求：get put post delete option

**get方式和post方式有何区别**

> get方式和post方式有何区别

数据携带上:

- GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。
- POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。

请求参数的位置上:

- GET方式：请求参数放在URL地址后面，以?的方式来进行拼接
- POST方式:请求参数放在HTTP请求包中

用途上:

- GET方式一般用来获取数据
- POST方式一般用来提交数据
- 原因:
- 首先是因为GET方式携带的数据量比较小，无法带过去很大的数量
- POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决)
- GET方式比POST方式要快
  GET方式比POST方式要快，

网站请求方式：GET 和POST

**GET：**

GET通常用于获取服务端数据。

常见发起GET请求的方式有：URL 、src/href、表单（form）。

GET方式提交数据的格式:

格式:index.php?userName=jack&password=123 （注意：index.php？key=value&key=value。 userName=jack&password=123 叫做查询字符串）

参数名与参数值之间没有空格

参数值不需要使用单双引号包括

**GET方式提交数据特点：**

1、get方式在url后面拼接参数，只能以文本的形式传递参数。

2、传递的数据量小，4kb左右（不同浏览器会有差异）。

3、安全性低，会将信息显示在地址栏。

4、速度快，通常用于对安全性要求不高的请求。

**POST请求：**

POST就是发送、提交。可以向指定的资源提交要被处理的数据。

如果使用表单方式进行提交，表单的method必须设置为POST。

![img](https://pics2.baidu.com/feed/8d5494eef01f3a298a494567702add355d607cae.jpeg?token=86667e122e76689c13a38741fc65c77d&s=9998C41216E25AA00F83E0D40300E0E3)

**post方式提交的特点：**

1、post提交数据相对于get的安全性高一些。（注意：抓包软件也会抓到post的内容，安全性要求高可以进行加密）

2、传递数据量大，请求对数据长度没有要求。

3、请求不会被缓存，也不会保留在浏览器的历史记录中。

4、用于密码等安全性要求高的场合，提交数据量较大的场合，如上传文件，发布文章等。

5、POST方式提交数据上限默认为8M（可以在PHP的配置文件post_max_size选项中修改）

# Controller注解

@GetMapping 用于将HTTP GET请求映射到特定处理程序方法的注释。

具体来说，@GetMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.GET)。

@PostMapping 用于将HTTP POST请求映射到特定处理程序方法的注释。

具体来说，@PostMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.POST)。

此外还有@PutMapping，@PatchMapping，@DeleteMapping同上

所以一般情况下都是用@RequestMapping（method=RequestMethod.）即可

---

springMVC开发中使用了许多注解，不仅方便开发，也使代码更加简洁。
常用的注解有：

---

@RequestMapping参数：
—>value：指定请求的实际地址，指定的地址可以是URI Template 模式
—>method：指定请求的method类型， GET、POST、PUT、DELETE等
—>consumes：定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
—>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回
—>params：指定request中必须包含某些参数值时，才让该方法处理。
—>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。

```text
@RequestMapping(value = "/{commentid}", method = RequestMethod.DELETE,
   consumes = "application/json",produces = "application/json",
   params = "myParam=myValue",headers = "Refer=12345678")
```

---

@GetMapping：映射url地址

@Controller参数注解：用于标注控制层

@RestController

\1. Controller, RestController的共同点

都是用来表示Spring某个类的是否可以接收HTTP请求

\2. Controller, RestController的不同点

@Controller标识一个Spring类是Spring MVC controller处理器

@RestController： a convenience annotation that does nothing more than adding the@Controller and@ResponseBody annotations。 @RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。

[![img](https://iknow-pic.cdn.bcebos.com/c75c10385343fbf228942d85bb7eca8064388fd8?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)](https://iknow-pic.cdn.bcebos.com/c75c10385343fbf228942d85bb7eca8064388fd8)

\3、如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。

例如：本来应该到success.jsp页面的，则其显示success.

\4、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。

\5、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。

---

@PathVariable：当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。

@RequestParam：常用来处理简单类型的绑定；也可用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；

【注：@RequestParam有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；】

@RequestBody：该注解常用来处理Content-Type: 如application/json, application/xml等(但不是application/x-www-form-urlencoded编码的内容)；

【注：它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。】

@RequestHeader：可以把Request请求header部分的值绑定到方法的参数上。

```text
public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, 
                              @RequestHeader("Keep-Alive") long keepAlive)  { …  }
```



@Autowired：自动装配，Spring下的注解类，代替成员变量的set/get方法；可用参数@Autowired(required = false) 表示在找不到匹配的Bean时也不报错，多用于测试阶段，@Autowired可以对成员变量、方法以及构造函数进行注释，
无论有无xml都会自动找对应bean或方法装配。

@Qualifier：类似@Autowired，区别在于：@Autowired注释进行byType注入，而@Qualifier是通过byName注入。

@Resource：类似@Autowired,按byName自动注入
两个属性：name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。

```java
@Resource(name="adGroup")
private AdGroup adGroup;
```

@CookieValue：可以把Request header中关于cookie的值绑定到方法的参数上。

```text
@RequestMapping("/displayHeaderInfo.do") 
public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie)  {  …  }
```

@Component：指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

@Service：用于标注业务层组件 

```java
@Service("courseDAO")
@Scope("prototype")
public class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{
......
}
```

```xml
<bean id="courseDAO"
      class="com.study.persistent.CourseDAOImpl" scope="prototype">
      ......    
</bean>
```

@Repository：用于标注数据访问组件，即DAO组件



# 运维相关

1 lvs基本的作用？
	lvs作用是linux的虚拟vip技术，注意阿里云购买的linux云服务默认情况下不支持虚拟vip技术
	使用lvs管理我们的nginx的集群

2 keepAlived基本作用？

多机热备份	keepAlived是一个心跳脚本的监测软件，比如可以间隔的发送我们心跳检测我们的tomcat是否有宕机，如果宕机的情况下keepAlived帮助我们自动去重启脚本，如果重启多次还是失败的情况下，会发送邮件告诉给运维人员。

3 请说明nginx + lvs + keepAlived 分别的作用
	nginx+lvs+keepAlived
	nginx作用：核心反向代理 请求的入口
	lvs：虚拟vip技术管理我们的nginx服务器
	KeepAlived：实现心跳检查

4 tomcat如果停止呢？你是如何解决
	注意：千万不要回答手动重启。
	我们可以采用tomcat集群实现故障转移，使用KeepAlived心跳检测我们的tomcat服务器，如果服务器宕机的情况下，自动重启我们的tomcat，如果重启多次还是失败的情况下，发送邮件告诉给运维人员自动重启。

5 项目正在发布时，如何解决用户无法访问的问题？

55 生产排查定位思路
linux命令 -> 搜关键词 -> 定位日志log -> 看堆栈信息 -> 分析异常原因
排查日志 -> 确认关键字 -> 产品ID

# 前后端分离

44 怎么理解前后端分离，如何实施？
老的技术jsp：js语言套html模板，不适合现在移动互联网开发，太多页面不适用，前端没有模板。
前后端分离，需要解耦，高内聚、低耦合。面向CV编程，收集代码片段。
vue.js和react.js才出来的，前端开发工程框架，更好复用了。
有线程按钮、表格、菜单和布局。element和ant design组件。

## 如何实施？
前后端都得满足工程化：演进迭代、可复用。
设计：**后**——后端架构、中间件、数据库、缓存。前后端接口约定，请求方式、数据类型、数据格式。
开发：按照约定，互相独立开发，mock模拟数据。一套后端供不同前端使用，web、app、小程序等等。
测试：前后端可独立测试，**后**——接口提供、格式、校验、异常情况、数据一致性问题、权限分配。
部署：前后端可独立部署。版本也可以独立发布。Jenkins持续发布。

# 动静分离

32 动静分离**1.准备工作。**

结合本文场景，需要安装Nginx和Java环境（运行SpringBoot项目）。

1.1 关于Linux系统安装Nginx可以参考我的文章—([传送门](https://link.zhihu.com/?target=https%3A//www.dalaoyang.cn/article/55))。

1.2 本文SpringBoot使用了Thymeleaf模板，项目端口号为8888。

1.3 在本地/Users/dalaoyang/Downloads/static文件内存放了jquery.js

**2.什么是动静分离？**

在弄清动静分离之前，我们要先明白什么是动，什么是静。

在Web开发中，通常来说，动态资源其实就是指那些后台资源，而静态资源就是指HTML，JavaScript，CSS，img等文件。

一般来说，都需要将动态资源和静态资源分开，将静态资源部署在Nginx上，当一个请求来的时候，如果是静态资源的请求，就直接到nginx配置的静态资源目录下面获取资源，如果是动态资源的请求，nginx利用反向代理的原理，把请求转发给后台应用去处理，从而实现动静分离。

在使用前后端分离之后，可以很大程度的提升静态资源的访问速度，同时在开过程中也可以让前后端开发并行可以有效的提高开发时间，也可以有些的减少联调时间 。

## 什么是网站动静分离架构模式？

​	动静分离架构模式就是将静态资源和动态资源分开到不同的服务器部署。
​	静态资源包含：css、img、html的等。
​	动态资源包含：api的接口 后端代码等。
​	动静分离的架构模式在高并发系统调优中运用非常广泛

# JVM

77 类初始化顺序
1 静态变量 静态初始化块
2 变量 初始化块
3 构造器

先父后子 2和3一起

**双亲委派加载**

**JVM内存模型**

**GC机制**

97 堆和栈

1. 内存结构：栈（局部变量）、堆（new 出来的结构 对象（成员变量）数组等）

2. 变量：成员变量 vs 局部变量 (方法内、方法形参、构造器内、构造器形参、代码块内)

46 JVM里，new出来的对象是在哪个区？再深入一下，问下如何查看和优化JVM虚拟机内存。

堆中

48 Java内存溢出

|      |      |      |      |
| :--: | :--: | :--: | ---- |
| Eden |  s0  |  s1  | Old  |

​						youngGC								15 次survive ====>

81 java对象的四种引用

强引用 new一个object，无论如何不会被jvm的gc回收
弱引用 只被弱引用的对象，每次jvm的gc都会回收它
软引用 存在于第二次gc之前
虚引用 没有真实引用，不存在对象整个生命周期 不被清除

72 java内存泄漏怎么办 **不会**

memery analyzer
jstack 查看线程
jmap 查看内存
jstat 查看性能

javap
javac
jstack



每个线程有自己独立程序计数器和运行栈，但是一个进程中不同线程共同使用一套堆和方法区，多线程操作公共系统资源是线程安全

# OOP七大原则



1. 单一职责：一个模块、类、方法不要承担过多任务

2. 开闭原则：对扩展开放，对修改关闭，添加一个功能应该是在基础上扩展，例如添加类或方法，而不是修改原有代码

   例如：策略设计模式+HashMap/SpringBoot容器

3. 里氏替换：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序逻辑行为不变、不被破坏

4. 接口隔离：客户端不应该强迫依赖它不需要的接口

   - 对于接口来说，如果某接口承担了与其无关的接口定义，违反了接口隔离原则

   - 对于功能点，细分功能点，按需添加，不要定义大而全

5. 依赖倒置原则

   - 高层不依赖低层，高低层模块通过抽象依赖，抽象不依赖具体实现细节，具体细节依赖抽象。
   - 要针对接口编程，用接口约束，不要针对实现编程
   
6. 迪米特法则 
   只与你朋友通信，避免同陌生人通信（高内聚，低耦合，同时保证系统结构清晰）

7. 合成/聚合复用原则：
   设计模式告诉我们对象委托优于类继承，从UML的角度讲，就是关联关系优于继承关系。尽量使用合成/聚合、尽量不使用继承。
   实现：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，以整合其功能。

# 设计模式

## 单例模式

**定义** 一个类只有一个应用实例，并且提供一个全局访问点。

1 单例模式生成一个实例，减少系统性能开销
2 在系统设置全局访问点，优化资源共享

**创建方法** 私有化构造器，**getInstance** 返回对象。

**五种常见单例模式** 

饿汉式 		线程安全，调用效率高，不能延迟加载 （类加载时，初始化实例）
懒汉式		线程安全，调用效率不高，能延时加载	（类加载时，定义实例，不初始化，get方法中判null）
DCL懒汉式 双重检查锁模式（判断两次null，再初始化实例，用同步代码块+.class锁，volatile保证原子性）
饿汉改进式 静态内部类，线程安全，调用效率高，可以延时加载（静态内部类创建，外部方法调用，但是反射可以破坏单例，使private失效）
枚举单例	线程安全，调用效率高，不能延迟加载（枚举是天生单例）

## 工厂模式

**定义** 创建者和调用者分离
**核心** 实例化对象不用new，用工厂方法代替（Factory）
		将选择实现类，创建对象统一管理和控制
		将调用者跟我们实现类解耦

**两种模式**
简单工厂模式	用来生产同一级结构中任意产品 （对于新增加产品，求已有代码）
虽然不符合设计原则，实际用的最多

>又叫静态工厂模式，不同类实现同一个接口，无法做到开闭原则

工厂方法模式	用来生产同一级结构中固定产品 （支持增加任意产品）

> 工厂和产品各做一个接口，各应用之

|   评价指标   | 模式选择 |
| :----------: | :------: |
|  结构复杂度  |   简单   |
|  代码复杂度  |   简单   |
|  编程复杂度  |   简单   |
| 管理上复杂度 |   简单   |

## 抽象工厂模式

**定义** 围绕一个超级工厂，创建其他工厂，该超级工厂称为其他工厂的工厂。提供了一个创建一系列相关或者相互依赖对象接口，无需指定他们的类

![image-20200225103813635](/Users/hawkii/Library/Application Support/typora-user-images/image-20200225103813635.png)

超级工厂 生产工厂 小米和华为
华为 生产 路由器 手机
小米 生产 路由器 手机 

三个接口，工厂 手机 路由器

**适用场景** 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。

**优点** 可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。低耦合

**缺点** 产品族的扩展将是一件十分费力的事情，增加新的产品，所有的工厂类都要修改，对产品等级结构的划分是非常重要的。增加系统抽象性和理解难度。

## 观察者模式

![image-20200226030042719](/Users/hawkii/Library/Application Support/typora-user-images/image-20200226030042719.png)

定义一个对象接口，每个观察者注册到对象ArrayList中，此外添加3方法，增加、删除、查询。当外界信息发生改变时，通过遍历ArrayList通知每一个观察者。

天气和公告牌：左边是若干个地方天气，右边是若干个观察者。
dataChange()则通知多个地方观察者。
update更新到观察者类内部变量，display打印

## 代理模式

![image-20200226180317952](/Users/hawkii/Library/Application Support/typora-user-images/image-20200226180317952.png)

**静态代理** 
角色分析

抽象角色：一般会用接口或者抽象类实现
真实角色：被代理角色
代理角色：代理真实角色，代理后我们会做一些附属操作
客户：访问代理对象的人

优点：
可以使真实角色的操作更加纯粹，不用关注一些公共事务
公共业务分工给代理
公共业务拓展时，方便集中管理

缺点：
一个真实角色对应一个代理角色，代码量翻倍，开发效率低

**动态代理**

动态代理和静态代理角色一样
动态代理的代理类是动态生成的，不是我们直接写好的
动态代理分两大类：基于接口的动态代理，基于类的动态代理
	接口：jdk动态代理
	类：cglib
	字节码：javasist

proxy提供了创建了动态代理类的实例静态方法，也是由这些方法创建所有动态代理类的超类
动态代理类要实现InvokationHandler的接口

- 被代理接口
- 生成代理类
- 调用代理程序的执行方法

[代理模式讲解](https://www.cnblogs.com/lwbqqyumidi/p/11991730.html)
[类的相关方法](https://www.cnblogs.com/wangenxian/p/10936640.html)

# Servlet

Servlet生命周期可分为5个步骤

1. **加载Servlet**。当Tomcat第一次访问Servlet的时候，**Tomcat会负责创建Servlet的实例**
2. **初始化**。当Servlet被实例化后，Tomcat会**调用init()方法初始化这个对象**
3. **处理服务**。当浏览器**访问Servlet**的时候，Servlet **会调用service()方法处理请求**
4. **销毁**。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，**让该实例释放掉所占的资源**。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁
5. **卸载**。当Servlet调用完destroy()方法后，等待垃圾回收。如果**有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作**。

- 简单总结：**只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。**

116



117**Servlet相关 API**

> doGet与doPost方法的两个参数是什么

1. HttpServletRequest：封装了与请求相关的信息
2. HttpServletResponse：封装了与响应相关的信息

![img](https://pic3.zhimg.com/80/v2-8471049538497da2dd181aa1f3a6f26e_720w.jpg)

> 获取页面的元素的值有几种方式，分别说一下

1. request.getParameter() 返回客户端的请求参数的值
2. request.getParameterNames() 返回所有可用属性名的枚举
3. request.getParameterValues() 返回包含参数的所有值的数组

> request.getAttribute()和request.getParameter()区别

用途上:

- request.getAttribute()， **一般用于获取request域对象的数据**(在跳转之前把数据使用setAttribute来放到request对象上)
- request.getParameter()， **一般用于获取客户端提交的参数**

存储数据上:

- request.getAttribute()可以获取Objcet对象
- request.getParameter()只能获取字符串(这也是为什么它一般用于获取客户端提交的参数)

118
**Servlet安全性问题**

由于Servlet是单例的，当多个用户访问Servlet的时候，**服务器会为每个用户创建一个线程**。**当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题**。

原则：

1. 如果一个**变量需要多个用户共享**，则应当在访问该变量的时候，**加同步机制synchronized (对象){}**

2. 如果一个变量**不需要共享**，则**直接在 doGet() 或者 doPost()定义**.这样不会存在线程安全问题

# 并发编程

## 1)现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执 行？

这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟 悉。这个多线程问题比较简单，可以用 join 方法实现。

## 2)在 Java 中 Lock 接口比 synchronized 块的优势是什么？

你需要实现一个高效的缓存，它允 许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写 像 ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。Java 线程面试的问题越来 越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下 Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。

## 3)在 java 中 wait 和 sleep 方法的不同？

通常会在电话面试中经常被问到的 Java 线程面试问题。最大的不同是在等待时 wait 会释放 锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。

## 4）用 Java 实现阻塞队列？

这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是 否能实际的用 Java 线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根 据这个问很多问题。如果他用 wait()和 notify()方法来实现阻塞队列，你可以要求他用最新 的 Java 5 中的并发类来再写一次。

## 5）用 Java 写代码来解决生产者——消费者问题?

与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在 Java 中怎 么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现 的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。

## 6）用 Java 编程一个会导致死锁的程序，你将怎么解决？

这是我最喜欢的 Java 线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍， 但是很多侯选者并不能写 deadlock free code（无死锁代码？），他们很挣扎。只要告诉他 们，你有 N 个资源和 N 个线程，并且你需要所有的资源来完成一个操作。为了简单这里的 n 可以替换为 2，越大的数据会使问题看起来更复杂。通过避免 Java 中的死锁来得到关于 死锁的更多信息。

## 7) 什么是原子操作，Java 中的原子操作是什么？

非常简单的 java 线程面试问题，接下来的问题是你需要同步一个原子操作。

## 8) Java 中的 volatile 关键是什么作用？怎样使用它？

在 Java 中它跟 synchronized 方法有什 么不同？自从 Java 5 和 Java 内存模型改变以后，基于 volatile 关键字的线程问题越来越流行。应该 准备好回答关于 volatile 变量怎样在并发环境中确保可见性。

## 9) 什么是竞争条件？你怎样发现和解决竞争？

这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条 件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条 件。可以参考我之前发布的关于 Java 竞争条件的文章。在我看来这是最好的 java 线程面试 问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or anyother race condition。关于这方面最好的书是《Concurrency practices in Java》。

## 10) 你将如何使用 threaddump？

你将如何分析 Thread dump？在 UNIX 中你可以使用 kill -3，然后 thread dump 将会打印日志，在 windows 中你可以使 用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很 棘手。

## 11) 为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？

这是另一个非常经典的 java 多线程面试问题。这也是我刚开始写线程程序时候的困惑。现 在这个问题通常在电话面试或者是在初中级 Java 面试的第一轮被问到。这个问题的回答应 该是这样的，当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我 之前写的《start 与 run 方法的区别》这篇文章来获得更多信息。

## 12) Java 中你怎样唤醒一个阻塞的线程？

这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了 IO 阻塞，我并 且不认为有一种方法可以中止线程。如果线程因为调用 wait()、sleep()、或者 join()方法而 导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。我之前写的 《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。

## 13)在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？

这个线程问题主要用来检测你是否熟悉 JDK5 中的并发包。这两个的区别是 CyclicBarrier 可 以重复使用已经通过的障碍，而 CountdownLatch 不能重复使用。

## 14) 什么是不可变对象，它对写并发应用有什么帮助？

另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个 java 面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 String 是不可变 的。

## 15) 你在多线程环境中遇到的常见的问题是什么？

你是怎么解决它的？多线程和并发程序中常遇到的有 Memory-interface、竞争条件、死锁、活锁和饥饿。问题 是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于 实际应用的 Java 线程问题。



# Redis

62 redis的场景数据模型
1 String	2 List	3 Hash	4 Set	5 Sorted Set

用处
1 分布式session+redis中
2 订单记录存在redis的list中

# 异常

67
error：程序无法处理系统错误，编译器不检查
exception：程序可以做处理，补货后处理



生成字节码中，方法都带有字节码表
from to 字节码行号范围 异常跳入target行

52 异常设计方案
	1 利用模板模式
	2 利用Spring拦截器

核心	 1 异常码
			2 异常描述
			3 执行结果

85 Error和Exception的区别
两者都是继承Throwable类
Error：系统错误，jvm的问题，应用程序中断，程序无法恢复
Exception：尽可能处理异常，使程序恢复
处理好：try/catch/finally+rerun的先后顺序

# SpringMVC

69 解释下SpringMVC

![img](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=859978010,3262158413&fm=26&gp=0.jpg)

request-->DispatcherServlet -->HandlerMapping记录Controller与路径关系

> ViewResolver 根据视图名称确定视图组件
>
> ModelAndView 1 返回到指定页面setName()+字符串 2 返回参数 addObject()方法到请求作用域中
>
> Controller	页面控制器，着力编写**业务层** service层 **数据访问层**dao层 前者new一个dao对象 操作它。

最后通过视图组件jsp或者html返回response。

**SpringMVC：**

1.客户端发送请求到DispacherServlet（分发器）

2.由DispacherServlet控制器查询HandlerMapping，找到处理请求的Controller

3.Controller调用业务逻辑处理后，返回ModelAndView

4.DispacherServlet查询视图解析器，找到ModelAndView指定的视图

5.视图负责将结果显示到客户端

# Linux

43 面试带入一些Linux高级命令
日志都是在Linux，下面归纳些实际的Linux操作。

1 能通过less命令打开文件，通过Shift+G到达文件底部，再通过?+关键字的方式来根据关键来搜索信息。
2 能通过grep的方式查关键字，具体用法是, grep 关键字 文件名，如果要两次在结果里查找的话，就用grep 关键字1 文件名 | 关键字2 --color。最后--color是高亮关键字。
3 能通过vi来编辑文件，sudo
4 能通过chmod来设置文件的权限。

# Maven

33 maven几个常用命令
clean ：清除由项目编译创建的target
install ：安装jar包到本地仓库。
deploy：命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库

34 pom包含三类信息
1 当前模块自身信息
2 依赖第三方jar包
3 插件

63 Maven冲突依赖
打印依赖树 mvndependency:tree  > tree.txt
Maven helper 查看冲突依赖，用exclusion排除依赖

# 序列化及反序列化

**前置信息：**

- 缓冲流 复制文件速度更快

- 客户端/浏览器端 ----- 后台(java, GO, Python, Node.js，php) ----- 数据库，要求前后统一 UTF-8

- 对象流，用于存储和读取基本数据类型数据或对象的处理流，把java对象写入数据源中，或者把对象从数据源中还原

- 序列化机制，允许把内存中java对象转换成和平台无关的二进制流，从而使得二进制流持久存在磁盘上，网络将二进制流存到某节点，其他程序获得这个二进制流，就可以恢复成原来java对象

- - 序列化：ObjectOutputStream 保存
  - 反序列化：ObjectInputStream 读取

- 转换流：OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节，将字符串按照指定的编码表转成字节，在使用字节流将这些字节写出去

- close()和flush()的区别?

- - close()关闭流对象，但是先刷新一次缓冲区。关闭之后，流对象不可以继续再使用。
  - flush()仅仅刷新缓冲区,刷新之后，流对象还可以继续使用。

- 异常和序列化都需要提供一个序列版本号（全局常量）

- - public static final long serialVersionUID = 65869324798275L

- 不能序列化 用static 和 transient修饰

- 不一定真的传输内存中可序列化对象，特殊格式字符串——json

---

83序列化和反序列化
序列化：对象转字节流
反序列化：字节流转回对象

序列化原因：
持久存储，网络传输，通过RMI(远程方法调用)传输对象

实现方法：通过Serializable接口
常见问题：
transient 属性不会序列化
static 属性不序列化
实现Serializable接口时候，一定要给SerialVersionUID
当属性是对象时候，对象也要有实现序列化接口

---

92 json和进程通信

对象的序列化，例如json字符串；

进程之间通信，通过序列化的json。

json：任意一个类的对象都可以转成字符串，这个字符串叫做json

json数组：用在多组对象

流章节，主要是讲对象的可序列化：基本数据类型，字符串(json特殊格式字符串)

json：任意一个类的对象都可以转成字符串，这个字符串叫做json

json数组：用在多组对象



进程之间通信，通过序列化的json。



对象流：ObjectInputStream 和 ObjectOutputStream

作用：  ObjectOutputStream：内存中对象-->存储中的文件、通过网络传输出去。

			ObjectInputStream：存储中的文件、通过网络接受文件——内存中的对象。

# 消息队列

35 MQ ：订单中台 调用各个微服务 如果吞吐量太大 高 TPS 需要个告诉缓存来将 数据流持久化(json) 通常放在SSD-NAS
Kafka 并发最好 100W TPS(标准消息量)
rocketMQ 50W TPS 优化消息零丢失 但是消息会重复消费
rabbitMQ <=10W TPS 性能差 社区活跃 消息会丢失

# SpringBoot和SpringCloud

113
**Spring** **Boot的缺点？**
Spring Boot作为一个微框架，离微服务的实现还是有距离的。没有提供相应的服务发现和注册的配套功能，自身的acturator所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于REST的落地，还需要自行结合实际进行URI的规范化工作。

---

53 SpringBoot
单独个体微服务能
能单独存在

SpringCloud
全局微服务治理框架，整合Boot。
不能单独存在

54 为什么用SpringCloud
	1 门槛低
	2 对周边支持力度大
	3 最适合微服务框架，发展迅速
	4 天然支持SpringBoot，便于业务落地
	5 来源于Spring，质量、稳定性、持续性都可保证

# 阻塞

83 
BIO同步阻塞
NIO同步非阻塞
AIO异步非阻塞，适用于数目多，时间长。调用API读写方法(异步)+回调方法

# 技巧

"::" : 关键字来访问类的构造方法，对象方法，静态方法。

聚合操作：建立在管道概念的基础上包括 -> 管道源（都是集合）-> 中间操作 -> 结束操作

回头再看一下 哈夫曼树 和 哈希散列的代码

----

88 慎用Object的Clone方法，除了8种基本数据类型+String等不可变类型，否则需要重写Clone方法(当类有复杂数据尤其是其他类)

61 如何防止重复提交
提交按钮后屏蔽提交js
前端生产唯一ID
后端唯一索引

49 避免过多 if else
通常业务需要判断：
1 空值判断
2 业务判断
3 状态判断

1、把接口分为外部和内部接口，所有空值判断放在外部接口完成；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。
2、利用多态，把业务判断消除，各子类分别关注自己的实现，并实现子类的创建方法，避免用户了解过多的类。预先定义一个抽象类，不同业务继承之。
3、把分支状态信息预先缓存在Map里，直接get获取具体值，消除分支。

----

3 服务器集群可能会存在哪些问题？
	服务器集群的作用：减轻单台服务器访问压力、实现故障转移。
	服务器集群存在问题：
	1 分布式Session一致性问题：Spring-Session框架原理就是将Session的内容缓存到Redis，所以可以直接采用token替代session
	2 分布式Job幂等性问题，重复执行多次，只执行一次或结果相同：XXL-JOB
	3 分布式日志的管理采集：elk-kafka
	4 分布式全局id如何生成，不能单台uuid：雪花算法
	误区：分布式事务属于rpc远程通讯多个数据之间存在分布式事务的问题。

4 软负载与硬负载的区别?
软负载是基于软件形式实现负载军均衡：Nginx、Ribbon
硬负载基于硬件基础设施形式实现负载均衡 F5

23 高并发解决方案的思路你有哪些
	核心思路：看项目是web还是移动app项目
	如果是web项目，因为网页中大多数是静态资源占用整个服务器带宽，所以需要采用动静分离架构模式
	**前端优化方案：**
	1 采用动静分离架构模式，将静态资源存入到第三方的对象存储服务器（对象存储服务器还可以自带CDN加速）
	2 对我们静态资源实现压缩 最好使用.min格式
	3 可以使用nginx+lua+OpenResty对我们静态页面实现布局缓存

​	**后端优化方案：**
​	1 使用微服务网关或者是nginx对我们接口实现api的限流，服务保护、黑名单和白名单等
​	2 使用Redis缓存减轻我们服务器访问的压力，Redis可以采用集群部署或者读写分离，提高吞吐量
​	3 使用多线程或者MQ异步处理我们代码可以快速的响应给客户端，如果项目比较小的情况下可以采用多线程处理，项目如果比较大的情况建议还是采用MQ异步处理，可以保证消息的可用性。
​	4 jvm、tomcat实现参数调优提高吞吐量、代码实现优化
​	5 Mysql服务器实现性能优化，分表分库、采用读写分离模式提高吞吐量

75 高并发优化思路简单总结

1. 添加负载均衡层，将请求均匀分配到系统层。
2. 系统层采用集群化部署多台机器，扛住初步的并发压力。
3. 数据库分库分表 + 读写分离或微服务
4. 缓存集群引入redis
5. 数据库进行优化，sql语句逻辑优化，null值判断，数据库缓存，数据库延迟加载（一个表就不要访问多个表）
6. 比如说消息中间件技术，也就是MQ集群，是非常好的做写请求异步化处理，实现削峰填谷的效果。

37 性能优化
1 前端架构 nginx负载均衡
2 阿里云 分库分表
3 单机变集群
4 Mysql慢查询日志 sql索引
5 前端CDN加速 分布式+页面缓存
6 请求数据加密 代码+数据+加密

36 用Spring MVC里的Controller无法满足跳转的需求。所以我一般还会主动问：你除了依照现有框架写业务代码时，还做了哪些改动？
回答：增加了Redis缓存，以避免频繁调用一些不变的数据。或者，在MyBitas的xml里，select语句where条件有isnull，即这个值有就增加一个where条件，对此，会对任何一个where增加一个不带isnull的查询条件，以免该语句当传入参数都是null时，做全表扫描。或者，干脆说，后端异步返回的数据量很大，时间很长，我在项目里就调大了异步返回的最大时间，或者对返回信息做了压缩处理，以增加网络传输性能。

101 import导入

- import导入源文件中指定包和接口
- import导入在包的声明和类声明之间
- 使用“xxx.*”结构导入xxx包下面所有结构
- 如果是java.lang包下定义的，可以省略
- 如果使用的类或接口是本包下面的，也可以省略

100 this

this 关键字 表明当前对象的属性 而不是形参

this.方法 或者 this.属性

UML图，unified modeling language统一建模语言

47Java的静态代理和动态代理有什么差别？最好结合底层代码来说。

79 jdk proxy动态代理

用反射机制实现，高效的生成类的方法，要求类必须基于统一的接口

cglib是用字节码asm生成的

其他 aspect j字节码拦截织入属性

# 网络编程

1 dns域名解析的整个过程？
	先查找本地的host文件是否有配置域名解析，本地没有的就去运营商查询。dns解析成ip+端口号

109
http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
默认80端口。

https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。
默认443端口。
1） 完成TCP三次同步握手
2） 客户端验证服务器数字证书，通过，进入步骤3
3） DH算法协商对称加密算法的密钥、hash算法的密钥
4） SSL安全加密隧道协商完成
5）网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改

所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。

90 网络编程两个主要问题：

1 如何准确定位网络上一台主机，定位主机上特定应用

2 找到主机后如何可靠高效进行数据传输

91 网络编程中的两个要素：

1 对应问题一：IP和端口号

2 对应问题二：提供网络通信协议：TCP/IP参考模型（应传网数物）



17 CDN(内容分发网络)内容分发基本的概念介绍
	将我们的静态资源缓存到全国各地节点，再遵循就近原则访问，从而减少访问距离延迟 服务器带宽传输

18 CDN内容分发底层的实现原理 ：与上面相同

19 一个网站访问卡慢真正原因
	如果是访问网站比较卡的情况下，分析请求时间，如果是很少人访问还是比较慢的情况下，大多数的原因是因为自己购买云服务器带宽不足

20 如何实现对静态资源压缩

# 注解和反射

- 开发过程中用框架，不会自己写组件，不会写JDBC，用Mybatis 等等框架应对更复杂实际开发场景 效率高
- 框架 = 注解(免去xml)+反射机制+设计模式
- 自定义注解，查看SuppressWarnings定义
- 注解里面（）其实是属性 不是方法
- 如何获取注解信息，通过反射来进行获取，调用

78 反射原理，运行状态下能获取类所有方法和属性，运行状态能调用对象任意方法和属性

反射三种方式：

通过类名
通过建立对象，getClass
通过路径和相对路径
反射可以改变final性质

# 类继承和泛型

- 接口没有构造器 关键词是 interface
- extend 继承，泛型类的子类继承时候可以指定类型
- 泛型类可以有多个参数，逗号隔开
- 异常类不能泛型
- 泛型类中的方法中 不能是静态的
- 泛型方法可以是static的，原因：泛型参数是在调用方法时确定的，并非在实例化类时确定的
- DAO data access object，即操作数据库；ORM object relational mapping，即一个表对应一个类
- 泛型在继承方面体现：
- - 尽管 类A是类B的父类，但是G<A>、G<B>二者不具备子父类关系，二者是并列关系；
  - 补充 类A是类B的父类，A<G>是B<G>的父类
- 通配符：？，可作为别人的父类
- - 类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是G<?>
- 有限制条件的通配符使用
- - ？extends A：G<? extends A> 可以作为G<A> 和 G<B>的父类，其中B是A的子类，类似于小于等于
  - ？super A：G<？super A>可以作为G<A>和G<B>的父类，其中B是A的子类，类似于大于等于

# 安全框架

Shiro三个核心组件：Subject, SecurityManager 和 Realms。
Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。
SecurityManager：它是Shiro框架的核心，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。
Realm：Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。一个安全性相关的DAO，数据访问层负责底层增删改查。

Spring Security不能脱离Spring，Shiro的功能它都有，对Oauth、OpenID也有支持

25 下面的逻辑创建权限表结构：
一个用户可以有多种角色（normal,manager,admin等等）
一个角色可以有多个用户（user1,user2,user3等等）
一个角色可以有多个权限（save,update,delete,query等等）
一个权限只属于一个角色（delete只属于manager角色）
26 用户应用的安全性包括：
用户认证（Authentication）
用户授权（Authorization）

28 duddo
类似于spring cloud的一个框架，apache公司，三大核心：面向接口的远程方法调用（RPC），智能容错和负载均衡，以及服务自动注册。

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=9a3d824f9b504fc2b652b85784b48c74/d01373f082025aaf111c708cfbedab64034f1a4e.jpg)

50 讲讲SpringAOP的应用

1 日志，最下面有日志注解
2 权限管理
3 Spring自身注解事务

SpringAOP：目标解耦业务逻辑和通用逻辑，结合实际应用说

功能：
日志记录：性能统计
安全控制：事务处理
异常处理

实现方式：
预编译：Aspect J
运行期动态代理：JDK动态代理

# 常见对象

86 什么是DO、BO、DTO、VO、AO、PO

PO：持久对象，对应数据库一条记录映射对象，有get/set方法，POJO持久化后就是PO
BO：业务对象，把业务逻辑封装为一个对象，包括DAO和RPC
VO：业务对象，包装整个界面的值
DTO：封装对数据库的访问，一张有100个字段，对应PO的100个属性。界面上只显示10个字段，用WEB service来获取数据，没必要把整个PO对象传递到客户端，这是我们用只有这10个属性的DTO来传递结果到客户端

它可以把POJO持久化为PO，用PO组装出来VO、DTO；用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。

98 java bean 是一种Java写成的可重用组件

所谓javabean，是指符合如下标准的java类

- 类是公共的，

- 有一个无参构造器（由于需要通过反射造对象）

- 有属性，且有对应get set方法

# 跨域问题

29 跨域：前端调用的后端接口不属于同一个域(域名或端口不同)，就会产生跨域问题。
**1、客户端浏览器解除跨域限制**（理论上可以但是不现实）
**2、发送JSONP请求替代XHR请求**（并不能适用所有的请求方式，不推荐）
**3、修改服务器端**（包括HTTP服务器和应用服务器）（**推荐**）

8 JSONNP解决网站跨域的问题存在哪些缺点？
	使用jsonp解决跨域的问题，jsonp最大缺陷只能支持get不能支持post请求，核心底层采用脚本注入的形式

1 网站跨域的问题有了解过么？
	产生的背景：在微服务架构项目中模式采用前后端分离，vue部署的域名和端口号有可能和接口的域名或者端口号不一致造成的。
	跨域的问题属于浏览器的安全策略，从浏览器中访问的域名或者是端口只要与页面中发送json请求如果域名或者端口号一致性的情况下能够成功访问到请求，但是不能够获取到结果。

2 如何解决网站跨域的问题？

- 在响应头中设置允许跨域的，只适合小公司
- 使用HttpClient转发 效率非常低
- 使用jsonp处理，json最大缺陷只支持get请求不支持post请求
- 使用nginx配置浏览器访问的项目与接口项目的域名或者端口号码一致性
  www.mayikt.com/vue 转发到vue项目
  www.mayikt.com/api 转发到接口项目
- 可以直接在nginx中配置允许跨域的问题

```nginx
Access-Control-Allow-Origin, *
```

- 网关中也可与配置类似于nginx允许跨域的代码

```nginx
Access-Control-Allow-Origin, *
```

- 使用springboot注解形式解决跨域问题

```java
@CrossOrigin
```

- 使用微服务网关也可以配置浏览器访问的项目与接口项目的域名或者端口号码一致性。

# CSD三层

## DAO层：
DAO层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说某个DAO一定是和数据库的某一张表一一对应的，其中封装了增删改查基本操作，建议DAO只做原子操作，增删改查。

## Service层：
Service层叫服务层，被称为服务，粗略的理解就是对一个或多个DAO进行的再次封装，封装成一个服务，所以这里也就不会是一个原子操作了，需要事物控制。

##Controler层：
Controler负责请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面。

## 总结：
个人理解DAO面向表，Service面向业务。后端开发时先数据库设计出所有表，然后对每一张表设计出DAO层，然后根据具体的业务逻辑进一步封装DAO层成一个Service层，对外提供成一个服务。
